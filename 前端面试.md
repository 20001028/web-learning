

# 前端面试题

### 前端基础

**XSS和CSRF**

- **XSS**：跨域脚本攻击，通过向客户端注入恶意脚本对客户端进行篡改，从而获取用户隐私数据或控制用户客户端

  **解决办法**

  Httponly：禁止js读取有该属性的cookie，阻止对客户端cookie的劫持

  输入检查：客户端输入

  输出检查：服务端输出

- **CSRF**：跨站请求伪造，劫持受信任用户向发送非预期请求给服务器

  **解决方法**

  验证码：强制用户与网站进行交互

  Referer Check：检查请求来源是否合法

  token：客户端随机生成token，作为参数发送给服务器，服务器对请求进行拦截，对token进行验证

**浏览器从输入URL到页面渲染**

- 域名解析
  1. 从浏览器缓存中查找是否有域名对应的ip
  2. 在hosts文件中查找
  3. 本地DNS域名解析
  4. 远程DNS域名解析

- 与服务器建立TCP连接（三次握手）
  1. 客户端发送报文给服务端（SYN=1,SEQ=X）
  2. 服务端同意连接（SYN=1,ACK=1,ack=x+1，seq=y）
  3. 客户端确认连接（ACK=1,ack=y+1，seq=x+1）

- 浏览器发出HTTP请求

- 服务器响应
- 浏览器进行渲染
  1. 将HTML解析为DOM树
  2. CSSDOM
  3. 合并DOM树和CSSDOM为Render Tree
  4. 渲染树布局
  5. 渲染树绘制

**同源策略和跨域**

- **同源策略**：协议、域名、端口相同，不受限制的有页面中的链接、重定向和表单提交，script标签、img

- **跨域**

  1. JSONP：动态创建script标签，利用script标签中的src属性不受同源策略约束跨域获取数据

     回调函数处理服务端返回的数据

     存在安全性问题（Referer校验和Token校验），只能GET不能POST，可能被注入恶意代码，篡改页面内容（XSS）

  2. CORS：向跨源服务器发出XHR请求

     在目标源中添加响应头声明允许请求源的访问

     ```
     Access-Control-Allow-Origin: http://a.com
     ```

  3. 降域：document.domain

     在父域名和子域名之间，如child1.a.com和a.com，两个页面都设置document.domain='a.com'，浏览器认为同源

     存在安全问题，一个站点被攻击后，另一个站点会有安全漏洞

  4. postMessage

  5. window.name

  6. location.hash

**服务端渲染和浏览器渲染**

1. 浏览器请求一个html，下载js和css文件，加载js文件，js异步请求数据，数据渲染
2. 浏览器请求一个已经有正确内容的页面，请求js和css文件，加载js，渲染剩余部分

**强缓存和协商缓存**

1. **强缓存**：浏览器向服务端请求资源时，服务端在响应头（response header）对资源的缓存配置，缓存时间和类型由服务端控制

   cache-control：max-age表示缓存的时间，public表示可以被浏览器和代理服务器缓存比如nginx，immutable表示就算用户刷新页面也不会去请求服务器，而是直接从本地磁盘或内存总读取缓存

   private：只有客户端可以缓存该资源，代理服务器不缓存

   no-cache：跳过设置强缓存，但是可以设置协商缓存；只有强缓存失效后才会走协商缓存

   no-store：不缓存，两种缓存都没有

2. **协商缓存**

   在response header里设置etag和last-modified

   etag：文件hash，每个文件唯一

   last-modified：文件的修改时间，精确到秒

   每次请求返回的响应头中的etag和last-modified，在下次请求时在请求头中带上，服务端进行对比，判断资源是否更改，如果更改，直接返回新的资源并更新对应的etag和last-modified

   为什么有etag：

   一些文件会周期性的更改，但仅仅改变修改时间而不修改内容

   某些文件修改非常频繁，在秒级以下的时间修改

   某些服务器不能精确得到文件的最后修改时间

**预加载和懒加载**

1. 预加载

   1. 核心：图片等静态资源在使用前提前请求

      ​			资源后续使用直接从缓存中加载，提升用户体验

   2. 注意：预加载不是为了减少页面加载时间，只是提前加载除去首轮加载的图片以后要用到的图片

   3. 三种方式：

      1. CSS+JS

      2. JS

      3. Ajax

         ```javascript
         window.onload=function(){
             setTimeout=(function(){
                 const xhr=new XMLHttpRequest();
                 xhr.open('GET','js文件地址');
                 xhr.send('');
                 xhr=new XMLHttpRequest();
                 xhr.open('GET','css文件地址');
                 xhr.send('');
                 new Image().src='图片地址';
             },1000);
         }
         ```

2. 懒加载

   1. 核心：只显示可以看到的图片资源，对于看不见的资源不请求

      ​			可以减少页面加载时间

      ​			适用于需要大量图片的页面

   2. 实现：将图片的src属性设为空，或者给一个底图的url避免页面结构混乱，再给一个自定义的data-url属性，存放图片真实路径，lazyload属性标明图片是否需要懒加载，在JS中监听滚动事件，图片出现在可视区才动态的将图片的真实地址赋予图片的src属性

**GET和POST的区别**

- GET请求只能url编码，POST支持多种编码方式
- GET请求传送的参数有长度限制（浏览器有关，2-3KB），POST没有限制
- GET比POST更不安全，参数暴露在URL中，不能传递重要的信息
- GET参数通过URL传递，POST放在请求体中
- GET请求的数据会被浏览器主动cache，POST不会（可以设置）
- GET在浏览器回退时无害，POST可能会再次提交请求

**前端性能优化**

- 网络加载类
  - 减少HTTP请求次数：合并图片、JS和css代码
  - 减少HTTP请求的大小，对JS、css、html代码以及图片进行压缩和优化
  - 把CSS和JS放到外部文件
  - 避免空的href和src
  - 指定Cache-Control
  - 合理设置Etag和Last-Modified
  - 减少页面重定向
  - 静态资源分域存放
  - CDN
  - 图片懒加载
  - 利用浏览器缓存
- 页面渲染类
  - 减少重绘和重排

**详解304状态码**



### HTML

### CSS

**CSS选择器和优先级**

- !important>行内样式>ID选择器>类选择器>元素>通配符>浏览器自定义或继承
- 同一级别后写的覆盖先写的
- 内联样式（元素内部的style）>内部样式表（写在head的style里）>外部样式表（style引入）>导入样式（import）

**水平垂直居中方案**

- 绝对定位和负边距

  一定要设置父元素的宽高，不会强行撑开，父元素absolute和relative没有关系，子元素必须是absolute

  需要知道具体的盒子的宽高

  ```css
  .box{
                  width: 300px;
                  height: 300px;
                  position: absolute;
                  background-color: black;
              }
  .box span{
                  position: absolute;
                  width: 100px;
                  height: 50px;
                  top: 50%;
                  left: 50%;
                  margin-left: -50px;
                  margin-top: -25px;
                  text-align: center;
                  background-color: brown;
              }
  ```

- 绝对定位加translate

  一定要设置父元素的宽高，不会强行撑开，父元素absolute和relative没有关系，子元素必须是absolute

  不需要知道子元素的宽高，可以自动撑开

  ```css
  .box{
                  width: 300px;
                  height: 300px;
                  position: relative;
                  background-color: black;
              }
  .box span{
                  position: absolute;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%);
                  text-align: center;
                  background-color: brown;
              }
  ```

- 绝对定位加margin:auto

  子元素absolute，需要设置宽高，设置top、left、right、bottom为0

  ```css
  .box{
                  width: 300px;
                  height: 300px;
                  position: relative;
                  background-color: black;
              }
  .box span{
                  position: absolute;
                  width: 100px;
                  height: 100px;
                  top: 0;
                  bottom: 0;
                  right: 0;
                  left: 0;
                  margin: auto;
                  text-align: center;
                  background-color: brown;
              }
  ```

- flex

  ```css
  .box{
                  width: 300px;
                  height: 300px;
                  display: flex;
                  align-items: center;
      			justify-content:center;
                  background-color: black;
              }
  .box div{
                  width: 150px;
                  height: 100px;
                  background-color: brown;
              }
  ```

- table-cell

  适用于子元素为行级元素，因为text-align:center

  ```css
  .box{
                  width: 300px;
                  height: 300px;
                  text-align: center;
                  vertical-align: middle;
                  display: table-cell;
                  background-color: wheat;
              }
  .box div{
                  width: 150px;
                  height: 100px;
                  background-color: brown;
              }
  ```

**CSS属性继承**

- 不可继承：盒子的margin、border、padding、跟宽高有关的，display，position，left四件，float
- 所有可继承：visibility，cursor
- 内联元素可继承：字体样式，字间距
- 列表元素可继承：list-style
- 表格元素可继承：border-collapse

**BFC：块级格式上下文**

- 是一个独立的渲染区域，只有盒级box参与，规定了内部box如何布局，并且与区域外部毫不相关

- 布局规则

  - 内部的box垂直方向放置
  - box垂直方向的距离由margin决定，一个BFC内部的相邻box的margin会重叠
  - BFC的区域不会与float box重叠
  - BFC是页面上一个隔离的独立容器，里面的元素不会影响到外面

- 创建方法（以下之一即可）

  - 根元素
  - 浮动元素（float不是none）
  - 绝对定位元素（absolute或fixed）
  - 内联块（display:inline-block)
  - 元素具有display:table-cell/table-caption/flow-root
  - overflow值不是visible的块元素

- 作用

  - 利用BFC避免margin重叠

    统一BFC的两个相邻的box会发生margin重叠，可以把第二个box用div包起来成为一个BFC

  - 自适应两栏布局

    每个盒子margin box左边，与包含块border box的左边接触，即使left是浮动的（float:left)

    BFC的区域不会与float box重叠，可以把右边right单独作为一个BFC，左边left浮动

  - 清除浮动

    不给父元素设置高度，子节点设置浮动时，会发生高度塌陷，我们需要清除浮动

    计算BFC的高度时，浮动元素参与计算，我们可以把父元素激活为BFC

### JavaScript

**数组方法**

不改变原数组

- concat：连接两个或多个数组，a1.concat(a2)
- every：
- some
- filter
- indexOf
- join：从数组创建字符串，参数seperator为分隔符默认逗号
- toString
- lastIndexOf
- map
- slice
- valueOf

改变原数组

- pop：删除数组最后一个元素，无参，返回数组最后一个元素（数组为空返回undefined）
- push：向数组末尾添加一个或多个元素，参数一个或多个，返回新数组的长度
- shift：删除数组的第一个元素，无参数，返回被删除的元素（数组为空返回undefined）
- unshift
- reverse：翻转数组，无参数，返回翻转后的数组
- sort
- splice

**垃圾回收机制**

- 标记清除：先沿根结点出发遍历对象，对访问过的对象进行标记，表示该对象可达，对没有标记的对象进行回收
- 引用计数：记录对象被引用的次数

**事件循环**

- 执行栈和主线程
- JS异步执行机制
  - 所有任务都会在主线程上执行
  - 主线程外有一个任务队列（TQ），只要异步任务有了结果，就在任务队列中添加一个事件
  - 执行栈中的所有同步任务执行完后，就会读取任务队列，等待的异步任务进入主线程执行
  - 主线程重复第三步
- 宏任务和微任务
  - 宏任务：script整体代码、setTimeout、setInterval、UI渲染、I/O
  - 微任务：Promise、process.nextTick
  - 如果存在微任务，执行所有的微任务；微任务执行完后，执行第一个宏任务，循环步骤。

### Vue

**Vue双向绑定原理**

**Vue的keep-alive**

props：  include（字符串或正则表达式，只有name匹配的组件会被缓存）

​				exclude（字符串或正则表达式，任何name匹配的组件都不会被缓存）

​				max（最多可以缓存多少组件）

```vue
<keep-alive include="test-keep-alive">
//缓存name为test-keep-alive的组件
    <component></component>
</keep-alive>
```

也可以结合router-view使用，具体使用见：https://blog.csdn.net/titoni_yunruohan/article/details/83785039

keep-alive的生命周期：

- activated：第一次进入该页面，钩子函数触发顺序created->mounted->activated
- deactivated：页面退出时会触发deactivated，当再次前进或者后退时只触发activated

被缓存过的组件切换的时候还会执行created钩子函数吗：不会，只会触发activated钩子函数，不会从created开始

监听组件的激活和失活状态：使用钩子函数activated和deactivated函数

**Vue-Router钩子函数**

- **全局钩子函数**

  - 全局前置守卫：router.beforeEach()，可以创建多个，按照创建顺序调用，异步解析执行

    ```javascript
    const router = new VueRouter({ ... })
    
    router.beforeEach((to, from, next) => {
        //to:即将进入的目标路由，from:即将离开的路由对象
        //next:函数，一定要调用这个方法才能导航，参数有：无参、false、新地址、error
      // ...
    })
    ```

  - 全局后置钩子函数：router.afterEach()，

    ```javascript
    router.afterEach((to, from) => {//不接收next参数，不会改变导航本身
      // ...
    })
    ```

- **路由独享钩子函数**

  - beforeEnter()：可以在路由配置时直接定义

    ```javascript
    const router = new VueRouter({
      routes: [
        {
          path: '/foo',
          component: Foo,
          beforeEnter: (to, from, next) => {
            // ...
          }
        }
      ]
    })
    ```

- **组件内钩子函数**

  - beforeRouteEnter()

  - beforeRouteUpdate()

  - beforeRouteLeave()

    ```javascript
    const Foo = {
      template: `...`,
      beforeRouteEnter (to, from, next) {
        // 在渲染该组件的对应路由被 confirm 前调用
        // 不！能！获取组件实例 `this`，但是可以在路由被confirm的时候通过回调函数调用
        // 因为当守卫执行前，组件实例还没被创建
          next(vm=>{
              //通过vm访问组件实例this
          })
      },
      beforeRouteUpdate (to, from, next) {
        // 在当前路由改变，但是该组件被复用时调用
        // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
        // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
        // 可以访问组件实例 `this`
      },
      beforeRouteLeave (to, from, next) {//禁止用户在未保存修改前离开，可以用next(false)来取消导航
        // 导航离开该组件的对应路由时调用
        // 可以访问组件实例 `this`
      }
    }
    ```

**Vue生命周期函数**

- beforeCreate：el和data都没有初始化
- created：完成data的初始化，el没有
- beforeMount：完成了data和el的初始化
- mounted：完成挂载
- beforeUpdate
- updated
- activated
- deactivated
- beforeDestory
- destoryed
- created和mounted的区别：created时dom还没有渲染，只是初始化属性值；mounted时dom树已经渲染，初始化页面完成后。

### 计算机网络

1. TCP和UDP的区别
   1. TCP是面向连接的，UDP是无连接的
   2. TCP提供高可靠性，无差错、不丢失、不重复、按序到达，UDP尽最大努力交付，不能保证可靠性
   3. UDP没有拥塞控制，网络中出现拥塞不会降低源主机的发送速率
   4. TCP连接只能是点对点的，UDP支持一对一、一对多、多对多交互通信
   5. TCP面向字节流，UDP面向报文
   6. TCP速度较慢，UDP具有较好的实时性。适用于高速传输和实时性较高的通信
   7. TCP对系统资源要求较高，UDP更轻量级

### 操作系统

1. **进程和线程的区别**
   1. 线程是程序执行的最小单位，进程是操作系统分配资源的最小单位
   2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
   3. 进程之间相互独立，同一进程下各个线程之间共享程序内存空间和进程级的资源，进程内的线程在其他进程不可见
   4. 线程上下文切换比进程上下文切换快得多
2. **进程之间如何通信**
   1. 消息队列：有消息的链表，存放在内核中
   2. 信号量：控制多个进程对共享资源的访问
   3. 信号：通知进程某个事件已经发生
   4. 共享内存：映射一段能被其他进程访问的内存
   5. 套接字：用于不同机器之间的进程通信
   6. 无名管道：半双工，数据单向流动，只在具有亲缘关系的进程间使用
   7. 有名管道：半双工，允许没有亲缘关系
   8. 高级管道：允许启动子进程

### 算法和数据结构

1. 原型和原型链

   创建一个对象new Person()，该对象有一个proto属性，指向构造函数的原型即Person.prototype，同时该对象也有一个constructor属性指向该构造函数.

   只有函数才有prototype，对象（函数也是对象）都有proto属性（proto属性也是对象），Object本身是个构造函数

   在访问obj.constructor时，obj本身并没有constructor属性，但是会沿着proto属性一直向上查找，直到为null为止

   原型链：由proto属性构成的查找属性的线

2. 垃圾回收机制

   1. 标记清除：先沿根结点触发遍历对象，对访问过的对象进行标记，表示该对象可达，对没有标记的对象进行回收，
   2. 引用计数：记录对象被引用的次数

3. bind、call、apply的区别

   1. bind：返回一个绑定该对象的函数，不执行该函数
   2. call：返回函数执行结果，参数列表
   3. apply：返回函数执行结果，参数数组
   4. 如果没有指定函数绑定的对象，则默认为window
   5. 改变函数this指向

4. new执行的四个步骤

   1. 创建一个空对象

   2. 把空对象的原型链连接到函数对象上

   3. 执行该函数并绑定this

   4. 如果函数返回一个对象，则返回该对象否则返回创建的obj

      ```javascript
      function myNew(){
          let obj={};
          
          let [constructor,...args]=[...arguments];
          
          obj.__proto__=constructor.prototype;
          
          let result=Function.prototypr.call(obj,...args);
          
          return typeof result==='object' ? result : obj;
          return result instanceof Object ? result : obj;
      }
      ```

      

5. 原始值和引用值的区别：Undefined、String、null、Number、Boolean；Object、Date、RegExp、Function、Array

   1. 原始值存储在栈中，引用值存储在堆中
   2. 原始值通过值的拷贝进行赋值，值的改变不会引起原始值的改变；引用值以引用的拷贝赋值，值的改变会引起引用值的改变
   3. 原始值的比较是值的比较，引用值的比较是引用的比较（比较是否为同一个对象）

6. 回流和重绘

   1. 回流：引起DOM元素的几何属性发生变化，需要重新计算和绘制
   2. 重绘：重新绘制新的样式

7. 事件循环

   JS把所有任务分为两类：同步任务和异步任务。同步任务在主线程排队执行，异步任务进入任务队列Task Queue，当同步任务执行完后，从任务队列中取出异步任务执行

8. defer和async的区别

   1. async：脚本下载完成后立即执行，无法保证脚本的执行顺序，在onload事件（所有资源都完成加载）之前完成
   2. defer：脚本下载完成后需要等待文档解析完成才可以执行，按顺序执行，在DOMContentLoaded（DOM树构建完成，图片等资源未完全加载）事件之前完成

9. MVVM与MVC的区别

   解决MVC中大量DOM操作使渲染性能降低，加载速度变慢

10. addEventListener和onclick的区别

    1. onclick同一时间只能绑定一个对象
    2. addEventListener可以绑定多个对象

11. JS中Class的实现

    基于原型

12. Symbol的作用

    1. 作为对象的属性
    2. 防止对象属性名冲突
    3. 模拟私有属性

13. JS实现数组去重

14. setTimeout看输出，怎么for循环输出1,2,3,4,5而不是6,6,6,6,6（let和闭包）

15. Vue双向绑定

16. HTTPS

17. CSS中的display，inline标签，block标签，p和div的区别，inline和block的区别

18. 怎么检测用户是否跳到别的标签页

19. Promise、Async、Generator函数的区别

    三个函数都是用来解决异步操作问题

    1. Promise：主要将原来的用回调函数的异步编程方法转成resolve和reject出发时间，用then和catch捕获成功或失败状态下执行相应的代码

       Promise将多个回调函数嵌套的回调地狱变成链式写法

    2. Generator：将函数分步骤阻塞，只有主动调用next方法才可以进行下一步

    3. Async：在await部分等待分会，返回后自动执行下一步。相较于Promise，async每次异步返回的结果从then中拿到最外层，不需要链式调用，只需要同步写就可以。但是async必须以一个promise对象开始，async通常与promise结合使用

20. ES5/6的继承的区别

    1. class声明会提升，但不能用于初始化赋值，类似let和const
    2. class内部启用严格模式
    3. class的所有方法不可枚举
    4. class的方法都没有原型对象prototype，也没有constructor，不能new
    5. 必须使用new来调用class
    6. class内部不能重写类名

21. Object.create(null)和{}的区别

    1. Object.create(null)创建的对象非常干净，没有其他的属性和方法以及原型等
    2. {}带有proto属性，在原型链上，可以继承原型链上的属性和方法

22. Object.keys()和for...in的区别

    1. Object.keys()只遍历对象自身的所有可枚举属性
    2. for...in遍历对象自身的和继承的所有可枚举属性

23. hasOwnProperty和in的区别

    1. obj.hasOwnProperty(key)不会去判断原型链上的属性
    2. in判断对象属性或原型中是否包含该属性

24. JS数组去重方法

    1. Set：无法去除空对象{}
    2. for循环嵌套+splice方法：不能去除NaN和{}
    3. indexOf方法
    4. sort排序+相邻元素比对
    5. includes方法：不能去除同样的对象
    6. hasOwnProperty方法：全部有效
    7. filter方法：不能去除同样的对象
    8. 递归去重：不能去除NaN和一样的对象
    9. Map：同上
    10. reduce方法+includes方法：不能去除一样的对象

25. this指向问题

    1. 在非箭头函数中，this指向调用其所在函数的对象，离谁更近就调用谁；

       构造函数中，this绑定被创建的新对象

       DOM事件中，this指向触发事件的元素

       内联事件：bind，call，apply

    2. 全局环境下：this总是指向全局对象（window）

    3. 函数上下文调用：

       1. 函数直接调用
          1. 严格模式：this为undefined
          2. 非严格模式，this默认指向全局对象window
       2. 对象中的this
          1. 对象内部方法的this指向调用方法的对象
          2. 函数的定义位置不影响this指向，只和调用函数的对象有关
          3. 多层嵌套的对象，内部方法的this指向离被调用函数最近的对象（window也是对象，内部对象调用方法的this指向内部对象，而不是window）
       3. 原型链中的this：仍然指向调用它的对象，即使调用的是原型链上的方法也指向大年对象
       4. 构造函数中的this：绑定创建的新对象，当构造函数返回的默认值是一个this引用的对象时，手动设置返回其他的对象，如果返回值不是一个对象，返回this
       5. call&apply：函数内部的this可以绑定到call或apply方法指定的第一个对象上，如果不是对象转换为对象
       6. bind：函数用永远绑定在第一个参数对象上，不管什么情况下的调用

    4. DOM事件处理函数中的this

       this指向触发该事件的元素

    5. setTimeout&setInterval

       内部的回调函数的this指向全局对象window（bin改变指向）

    6. 箭头函数的this

       不绑定this，捕获上下文的this作为自己的this

26. Map和WeakMap

    1. WeakMap值接受对象作为键名（除了null），WeakMap键名指的对象不计入垃圾回收机制
    2. WeakMap的键名引用的对象都是弱引用，垃圾回收机制不考虑该引用，只要引用的对象其他应用都被清除，就会释放对象所占的内存，不需要手动删除

27. 为什么0.1+0.2不等于0.3

    因为JS中采用IEEE75的双精度标准，内部存储数据编码时，0.1并不是存储为精确的0.1而是有误差的0.1，被四舍五入为一个接近的数字

    解决方法：提升10的n次方为整数或者做差值计算在某个范围内即可

28. vue两种路由模式

    1. hash：地址栏中的#符号，#/index，hash虽然在url中，但不会包含在url请求中，对后端没有影响，改变hash不会重新加载页面
    2. history：基于H5增加的pushState和replaceState方法，应用于浏览器的历史记录站，在当前已有的back、forward、go的基础上提供对历史记录修改单功能，虽然改变了当前的url但不会立即向后端发送请求，可能会出现404错误，需要后台配置

29. BFC

    块级格式化上下文，是一个独立的渲染区域，只有块级盒子参与，规定内部盒子如何布局并且与外部没有关系

    内部的box在垂直方向放置

    距离由margin决定，相邻box的margin会重叠

    box的左边与整个大盒子的左边接触

    bfc区域不会与float box重叠

    bfc是页面上的一个隔离的独立容器，里面的子元素不会影响到外面的元素

    计算BFC高度时，浮动元素也参与计算

30. CSS预处理

    1. 预先处理CSS，扩展了CSS，增加了变量函数等编程特性，更容易维护和扩展

    2. CSS的缺点：语法不够强大，无法嵌套书写，需要书写很多重复的选择器

       ​						没有变量和复用机制

    3. 预处理的优点：提供样式复用机制，减少冗余的代码提高可维护性

31. CSS居中方法

    1. 子元素设置display:inline-block，vertical-align:middle
    2. flex实现：父元素display:flex，子元素align-self:center
    3. 伪元素before实现：父元素添加:before，其他样式参考1
    4. 父元素display:table，子元素display:table-cell
    5. line-height实现，让子元素该值等于父元素height，适用于子元素为单行文本

32. 不同标签页之间的通信

    1. localstorage：浏览器多个标签共用的存储空间，实现多标签之间的通信（session是会话级的存储空间，每个标签页都单独），onstorage事件和storage事件都是非当前页面对localstorage进行修改时才会触发，当前页修改不会触发监听函数。在对原有数据值修改后才会触发。
    2. sharedworker：一种可以共享的web worker，shareedworker可以共享线程，不同页面使用同一个sharedworker，当所有页面关闭后才会结束该线程，消息通过shareworker.port传递。sharedworker可以被多个window共同使用，但必须保证标签页同源

33. 计算机网络五层模型

    1. 物理层：以二进制数据在物理媒体上传输数据，IEEE802

    2. 数据链路层：传输有地址的帧、错误检测，PPP、ARP、RARP

    3. 网络层：为数据包选择路由，IP、ICMP、RIP

    4. 传输层：提供端对端的接口，TCP、UDP

       TCP：面向连接，字节流传输，全双工通信，可靠传输（确认重传、流量控制、拥塞控制）

    5. 应用层：文件传输、电子邮件，FTP、SMTP、HTTP

34. HTTP和HTTPS的区别

    1. HTTP明文传输，数据未加密，安全性比较差，HTTPS数据传输过程加密，安全性高
    2. 使用HTTPS协议需要到CA申请证书，一般免费证书较少，需要一定费用
    3. HTTP页面响应速度比HTTPS快，HTTP客户端和服务器需要交换3个包，HTTPS还要加上ssl握手的9个包
    4. HTTP和HTTPS使用完全不同的连接方式，端口也不一样，HTTP是80，HTTPS是443
    5. HTTPS就是建构在SSL上的HTTP协议，HTTPS比HTTP更耗费服务器资源

35. TCP和UDP区别

36. 